import { z } from "zod";

export const LearningPathNodeTransitionCreateSchema = z.object({
  fromNodeId: z.string(),
  toNodeId: z.string(),
  condition: z.string().optional(),
});

export const LearningPathNodeCreateSchema = z.object({
  lpId: z.string(),
  loId: z.string(),
  instruction: z.string().optional(),
  startNode: z.boolean(),
});

export const LearningPathCreateSchema = z.object({
  hruid: z.string(),
  language: z.string(),
  title: z.string(),
  description: z.string().optional(),
  image: z.string().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
});

export type LearningPathCreateParams = z.infer<typeof LearningPathCreateSchema>;

export type LearningPathNodeCreateParams = z.infer<typeof LearningPathNodeCreateSchema>;

// ODO maybe change to shorter name
export type LearningPathNodeTransitionCreateParams = z.infer<typeof LearningPathNodeTransitionCreateSchema>;



export const LearningPathFilterSchema = z.object({
  keywords: z.array(z.string()).optional(),
  age: z.array(z.string())
    .transform((val) => val.map(Number))
    .optional(),
  id: z.string().optional(),
});

export type LearningPathByFilterParams = z.infer<typeof LearningPathFilterSchema>;

export const LearningPathByIdSchema = z.object({
  id: z.string().uuid("Id must be a valid UUID"),
});

export type LearningPathByIdParams = z.infer<typeof LearningPathByIdSchema>;


export const PaginationFilterSchema = z
  .object({
    page: z
      .string()
      .regex(/^\d+$/, "Page must be a positive integer")
      .transform(Number)
      .refine((val) => val > 0, "Page must be greater than 0")
      .default("1"),

    pageSize: z
      .string()
      .regex(/^\d+$/, "PageSize must be a positive integer")
      .transform(Number)
      .refine((val) => val > 0, "PageSize must be greater than 0")
      .default("10"),
  })
  .transform((data) => {
    // Transform to include skip
    const page = data.page;
    const pageSize = data.pageSize;
    const skip = (page - 1) * pageSize;
    return {
      page,
      pageSize,
      skip,
    };
  });

export type PaginationParams = z.infer<typeof PaginationFilterSchema>;

export const ClassFilterSchema = z.object({
  name: z.string().min(1, "Name must be a non-empty string").trim().optional(),
  teacherIds: z
    .array(
      z.string()
      // TODO: Uncomment this line when we have teacher entries in the databse with uuids
      //.uuid("Each teacherId must be a valid UUID")
    )
    .optional(),
  studentIds: z
    .array(
      z.string()
      // TODO: Uncomment this line when we have student entries in the databse with uuids
      //.uuid("Each studentId must be a valid UUID")
    )
    .optional(),
});

export type ClassFilterParams = z.infer<typeof ClassFilterSchema>;

export const ClassCreateSchema = z.object({
  name: z.string().min(1, "Name must be a non-empty string").trim().optional(),
});

export type ClassCreateParams = z.infer<typeof ClassCreateSchema>;

export const ClassUpdateSchema = z.object({
  name: z.string().min(1, "Name must be a non-empty string").trim().optional(),
});

export type ClassUpdateParams = z.infer<typeof ClassUpdateSchema>;

export const ContentTypeEnum = z.enum([
  "TEXT_PLAIN",
  "TEXT_MARKDOWN",
  "IMAGE_IMAGE_BLOCK",
  "IMAGE_IMAGE",
  "AUDIO_MPEG",
  "APPLICATION_PDF",
  "EXTERN",
  "BLOCKLY",
]);

export const learningObjectKeywordSchema = z.object({
  keyword: z.string().min(1, "Keyword is required"),
});

export type LearningObjectKeywordParams = z.infer<typeof learningObjectKeywordSchema>;

export const LearningObjectCreateSchema = z.object({
  hruid: z.string().min(1, "HRUID is required"),
  uuid: z.string().uuid(),
  version: z.number().int().min(1, "Version must be a positive integer"),
  language: z.string().min(1, "Language is required"),
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  contentType: ContentTypeEnum.optional(),
  targetAges: z.array(z.number().int().nonnegative()).optional(),
  teacherExclusive: z.boolean().default(false),
  skosConcepts: z.array(z.string()).optional(),
  educationalGoals: z.array(z.any()).optional(), // JSON array
  copyright: z.string().optional(),
  licence: z.string().optional(),
  difficulty: z.number().optional(),
  estimatedTime: z.number().optional(),
  returnValue: z.any().optional(), // JSON object
  available: z.boolean().default(true),
  createdAt: z.date().optional(), // Auto-generated by Prisma
  updatedAt: z.date().optional(), // Auto-generated by Prisma
  content: z.string().min(1, "Content is required"),
  multipleChoice: z.any().optional(), // JSON object
  canUploadSubmission: z.boolean().default(false),
  learningObjectsKeywords: z.array(learningObjectKeywordSchema).optional(),
});

export type LearningObjectCreateParams = z.infer<typeof LearningObjectCreateSchema>;

export type LearningObjectWithoutKeywords = Omit<LearningObjectCreateParams, "learningObjectsKeywords">;

export const LearningObjectUpdateSchema = LearningObjectCreateSchema.partial();

export type LearningObjectUpdateParams = z.infer<typeof LearningObjectUpdateSchema>;

export type LearningObjectUpdateWithoutKeywords = Omit<LearningObjectUpdateParams, "learningObjectsKeywords">;

export const LearningObjectFilterSchema = z.object({
  keywords: z.array(z.string()).optional(),
  targetAges: z.array(z.string())
    .transform((val) => val.map(Number))
    .optional(),
  id: z.string().optional(),
});

export type LearningObjectFilterParams = z.infer<typeof LearningObjectFilterSchema>;
